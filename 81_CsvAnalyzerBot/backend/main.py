import os
from pathlib import Path
import shutil
from typing import Optional, List, Dict, Any
import uvicorn

from fastapi import FastAPI, UploadFile, File, Form, HTTPException, Request
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel

from backend.config import Config
from backend.csv_processor import CSVProcessor
from backend.agent import CSVAnalyzerAgent
from backend.chart_generator import ChartGenerator

app = FastAPI(
    title="CSVAnalyzerBot",
    description="AI agent that analyzes CSV files via natural language.",
    version="1.0.0"
)

# Ensure upload and charts directories exist and define them early
UPLOAD_DIR = Path(Config.UPLOAD_DIR)
CHARTS_DIR = Path(Config.CHARTS_DIR)
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
CHARTS_DIR.mkdir(parents=True, exist_ok=True)

# Mount static files (for CSS/JS in frontend)
app.mount("/static", StaticFiles(directory="frontend/static"), name="static")
app.mount("/charts", StaticFiles(directory=CHARTS_DIR), name="charts") # Mount charts directory

# Templates for serving HTML
templates = Jinja2Templates(directory="frontend")

# Initialize services
csv_processor = CSVProcessor()
csv_analyzer_agent = CSVAnalyzerAgent()
chart_generator = ChartGenerator()


class ChatRequest(BaseModel):
    question: str
    file_id: Optional[str] = None
    llm_choice: Optional[str] = "gemini" # Add LLM choice


@app.on_event("startup")
async def startup_event():
    Config.validate()
    print("CSVAnalyzerBot backend started.")


@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})


@app.post("/uploadfile/")
async def upload_csv(file: UploadFile = File(...)):
    if not file.filename.endswith(".csv"):
        raise HTTPException(status_code=400, detail="Only CSV files are allowed.")

    file_location = UPLOAD_DIR / file.filename
    with open(file_location, "wb+") as file_object:
        shutil.copyfileobj(file.file, file_object)
    
    # Load the CSV into the processor
    if csv_processor.load_csv(str(file_location)):
        return JSONResponse({"message": "File uploaded and processed successfully", "filename": file.filename, "file_id": file.filename})
    else:
        raise HTTPException(status_code=500, detail="Failed to process CSV file.")


@app.get("/data-summary/{file_id}")
async def get_data_summary(file_id: str):
    if csv_processor.get_dataframe() is None or csv_processor.file_path != str(UPLOAD_DIR / file_id):
        # Reload if it's a different file or not loaded
        file_path = UPLOAD_DIR / file_id
        if not file_path.exists():
            raise HTTPException(status_code=404, detail="File not found.")
        if not csv_processor.load_csv(str(file_path)):
            raise HTTPException(status_code=500, detail="Failed to load CSV for summary.")

    df_info = csv_processor.get_info()
    df_describe = csv_processor.get_summary_statistics()
    column_names = csv_processor.get_column_names()

    return JSONResponse({
        "filename": file_id,
        "info": df_info,
        "describe": df_describe,
        "columns": column_names
    })


@app.post("/analyze/")
async def analyze_csv_data(chat_request: ChatRequest):
    if csv_processor.get_dataframe() is None:
        raise HTTPException(status_code=400, detail="No CSV file loaded. Please upload a file first.")

    df = csv_processor.get_dataframe()
    
    # Pass LLM choice to agent
    csv_analyzer_agent.model_choice = chat_request.llm_choice 
    analysis_result = csv_analyzer_agent.analyze_csv(df, chat_request.question)
    
    response_text = analysis_result.get("response", "")
    chart_suggestion = analysis_result.get("chart_suggestion", None)

    chart_url = None
    if chart_suggestion:
        chart_filename = chart_generator.generate_chart(df, chart_suggestion)
        if chart_filename:
            chart_url = f"/charts/{chart_filename}"

    return JSONResponse({
        "response": response_text,
        "chart_suggestion": chart_suggestion, 
        "chart_url": chart_url
    })


@app.get("/charts/{filename}")
async def get_chart(filename: str):
    file_path = CHARTS_DIR / filename
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Chart not found.")
    # For plotly html charts, return as HTMLResponse
    if filename.endswith(".html"):
        return HTMLResponse(content=file_path.read_text(), status_code=200)
    # Fallback for other chart types (e.g. static images if generated by matplotlib)
    return FileResponse(file_path)


@app.get("/download-summary/")
async def download_summary(file_id: str):
    if csv_processor.get_dataframe() is None or csv_processor.file_path != str(UPLOAD_DIR / file_id):
        file_path = UPLOAD_DIR / file_id
        if not file_path.exists():
            raise HTTPException(status_code=404, detail="File not found.")
        if not csv_processor.load_csv(str(file_path)):
            raise HTTPException(status_code=500, detail="Failed to load CSV for summary.")

    df_info = csv_processor.get_info()
    df_describe = csv_processor.get_summary_statistics()
    column_names = csv_processor.get_column_names()

    summary_content = f"Data Summary for {file_id}\n\n"
    summary_content += f"Columns:\n{', '.join(column_names)}\n\n"
    summary_content += f"DataFrame Info:\n{df_info}\n\n"
    summary_content += f"Summary Statistics:\n"
    for stat, values in df_describe.items():
        summary_content += f"  {stat}:\n"
        for col, val in values.items():
            summary_content += f"    {col}: {val}\n"

    summary_filename = f"summary_{file_id.replace('.csv', '')}.txt"
    summary_path = UPLOAD_DIR / summary_filename
    with open(summary_path, "w") as f:
        f.write(summary_content)
    return FileResponse(path=summary_path, filename=summary_filename, media_type="text/plain")


@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "message": exc.detail, 
            "code": exc.status_code
        }
    )


if __name__ == "__main__":
    uvicorn.run("main:app", host=Config.HOST, port=Config.PORT, reload=Config.DEBUG)
